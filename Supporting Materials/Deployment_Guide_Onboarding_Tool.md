
# Deployment Guide: New Hire Onboarding Tool

## Goal
To guide a student through the final assembly and deployment of the full‑stack **New Hire Onboarding Tool**. This document consolidates all artifacts from the course into a single, runnable application packaged within a Docker container.

**Who this is for:** Students who have completed the course labs and want a step‑by‑step walkthrough to deploy the end‑to‑end application.

---

## 🔎 Pre‑Requisites (Preflight Checks)

Before you begin, please run these commands in your terminal to ensure your environment is ready:

```bash
# 1. Verify Docker Desktop is installed and running.
docker --version

# 2. Verify Node.js and npm are installed (used by Docker to build the frontend).
node --version
npm --version
```

**Expected Output:** You should see version numbers for Docker (e.g., 20.10+), Node (e.g., 18.0+), and npm (e.g., 9.0+). If not, please install the missing software before proceeding.

---

## 1. Application Architecture: A Deeper Look

Before we assemble the parts, let's clarify the architecture of the application you've built. Understanding how the pieces interact is key to a successful deployment.

- **Backend (Python & FastAPI):** This is the application's engine. It handles all business logic, manages users and tasks (CRUD operations), interacts with the database, and hosts the powerful AI chat agent you developed. It exposes a REST API that the frontend will communicate with.
- **Frontend (React):** This is the user interface (UI) that your users will see and interact with. The labs used AI vision models to generate individual UI components (like login forms and buttons) from design mockups, which we will assemble into a complete application.
- **Database (SQLite):** This is the application's memory. The `onboarding.db` file is a lightweight, file-based database that stores all persistent data, such as user information and the status of onboarding tasks.
- **AI Features (RAG & LangGraph):** Integrated directly into the FastAPI backend is the advanced Retrieval-Augmented Generation (RAG) agent. When a user interacts with the `/chat` endpoint, this system retrieves relevant information from your project's documents (the knowledge base) to generate intelligent, context-aware responses.
- **Deployment (Docker):** To make the application portable and easy to run, we will package the entire application—both the FastAPI backend and the React frontend—into a single, self-contained Docker container.

---

## 2. Inventory of Required Artifacts

The following table lists every file you'll need, its purpose, the lab where it was created, and whether it was generated by GenAI. Ensure you have all these artifacts ready.

| Artifact | Description | Generated In Lab(s) | AI-Generated? |
|---|---|---|---|
| `app/main.py` | The core FastAPI application, including API endpoints, database logic, and the RAG agent chat endpoint. | Day 3, Lab 1 (Backend Dev); Day 6, Lab 2 (Conversational System) | Yes |
| `requirements.txt` | A list of all Python libraries the backend needs to run (e.g., `fastapi`, `sqlalchemy`, `langchain`). | Day 4, Lab 2 (CI/CD Pipeline) | Yes |
| `artifacts/onboarding.db` | The physical SQLite database file, containing the tables and seed data for the application. | Day 2, Lab 1 (System Design & Seeding) | Yes (Schema & Seed) |
| `artifacts/day1_prd.md` | The Product Requirements Document, which serves as the primary knowledge base for the RAG agent. | Day 1, Lab 2 (Generating a PRD) | Yes |
| `frontend` components (`*.jsx`) | The UI components (e.g., `Login.jsx`) generated from design images using vision models. | Day 8, Lab 1 (Vision-Enabled UI/UX Agents) | Yes |
| `Dockerfile` | A set of instructions for Docker to build the container image for our application. | Day 4, Lab 2 (CI/CD Pipeline) | Yes |
| `.env` | A critical configuration file that stores secrets, such as your `OPENAI_API_KEY`. | Day 1 (Setup, as per README.md) | No |

---

## 3. Assembling the Application

This is where we bring everything together into a cohesive project structure.

### Step 1: Organize the Project Structure

Create the following directory structure. This organization is a standard for web applications and is what our Dockerfile will expect.

```
onboarding-tool/
│
├── 📁 app/                 # Backend Application Code
│   └── main.py
│
├── 📁 artifacts/           # Database and RAG Knowledge Base
│   ├── onboarding.db
│   └── day1_prd.md
│
├── 📁 frontend/            # React Frontend Project
│   ├── src/
│   │   └── components/     # Place AI-Generated React Components here
│   ├── package.json
│   └── (other React files...)
│
├── 📁 tests/               # Your test suite from Day 4
│
├── 📄 Dockerfile           # (We will enhance this below)
├── 📄 requirements.txt
├── 📄 .dockerignore        # Recommended: Create this file
└── 📄 .env
```

**Recommended:** Create a `.dockerignore` file in your root directory to speed up builds.

```gitignore
# .dockerignore
.git
**/__pycache__/
**/*.pyc
node_modules
frontend/node_modules
frontend/dist
.env
```

### Step 2: Assemble the Backend (Python/FastAPI)

- **Place the code:** Ensure your final `app/main.py` (which includes the `/chat` endpoint from Day 6) is correctly placed.
- **Verify database connection:** This is a crucial step. Inside `app/main.py`, the line that defines the database URL must be a relative path that works inside the container.

```python
# In app/main.py
SQLALCHEMY_DATABASE_URL = "sqlite:///./artifacts/onboarding.db"
```

### Step 3: Assemble the Frontend (React)

- **Initialize React project:** If you don't already have one, open your terminal in the `frontend/` directory and create a new React project using Vite.

```bash
# Run this command inside the 'frontend' directory
npm create vite@latest . -- --template react
```

- **Integrate components:** Move the `.jsx` files generated in Day 8 into the `frontend/src/components/` directory.
- **Use the components:** Open `frontend/src/App.jsx` and import your components to build your main application page.
- **Install dependencies:**

```bash
# Run this command inside the 'frontend' directory
npm install
```

### Step 4: Connect Frontend and Backend

We will configure our Python backend to serve the static files of our React frontend.

- **Build the React App:** Create the optimized, static build of your React app. (Our Dockerfile will automate this, but you can run it manually to test.)

```bash
# Run this command inside the 'frontend' directory
npm run build
```

- **Configure FastAPI to Serve Static Files:** Add the following Python code to `app/main.py`. This tells FastAPI to act as a web server for the React files.

```python
# In app/main.py, near the top
from fastapi.staticfiles import StaticFiles
from fastapi.responses import FileResponse
import os

# ... after app = FastAPI()

# Define the path to the React build output inside the container.
STATIC_DIR = "app/static"

# Mount the static assets directory (for CSS, JS, etc.)
app.mount("/assets", StaticFiles(directory=os.path.join(STATIC_DIR, "assets")), name="assets")

@app.get("/{full_path:path}")
async def serve_react_app(full_path: str):
    """
    Serves the main index.html for any route that is not an API route.
    This allows React Router to handle client-side navigation.
    """
    # For any path that is not an API, serve the main html file.
    return FileResponse(os.path.join(STATIC_DIR, 'index.html'))

# IMPORTANT: All your API routes (e.g., @app.get("/api/users")) MUST
# be defined *before* this static file serving configuration.
```

---

## 4. Containerization: The Enhanced Dockerfile

Replace the contents of your `Dockerfile` with this enhanced multi-stage version.

```dockerfile
# --- Stage 1: Build the React Frontend ---
# Use a Node.js image and name this stage 'frontend-builder'
FROM node:18-alpine AS frontend-builder
WORKDIR /app/frontend

# Copy package files and install dependencies first for better caching
COPY frontend/package*.json ./
RUN npm install

# Copy the rest of the frontend source code
COPY frontend/ ./

# Build the React application for production
# For Vite, output is in /app/frontend/dist
RUN npm run build

# --- Stage 2: Final Production Image ---
# Start from a lightweight Python image
FROM python:3.11-slim
WORKDIR /app

# Install Python dependencies
COPY requirements.txt ./
RUN pip install --no-cache-dir -r requirements.txt

# Copy the Backend application code
COPY app/ ./app/

# Copy the built React files from the 'frontend-builder' stage.
# NOTE: If your React build output is 'build', change 'dist' to 'build'.
COPY --from=frontend-builder /app/frontend/dist ./app/static

# Copy the database and RAG knowledge base
COPY artifacts/ ./artifacts/

# Expose the port FastAPI will run on
EXPOSE 8000

# Command to run the application
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
```

---

## 5. Deployment and Execution

### Quickstart (TL;DR)

```bash
# From your project root (where the Dockerfile is)
docker build -t onboarding-tool .

# Run with your secrets from .env
docker run -p 8000:8000 --env-file .env onboarding-tool
```

### Build the Docker Image

Open your terminal in the root directory of the project and run:

```bash
docker build -t onboarding-tool .
```

### Run the Docker Container

Now, run the image you just built:

```bash
docker run -p 8000:8000 --env-file .env onboarding-tool
```

### Access and Verify

Your application is now running!

- **Frontend UI:** <http://localhost:8000>  
- **Backend API Docs:** <http://localhost:8000/docs>

Verify with `curl`:

```bash
# Check if the API docs page loads
curl -s -o /dev/null -w "%{http_code}
" http://localhost:8000/docs
# Expected output: 200
```

---

## 6. Troubleshooting Guide for Beginners

If you run into issues, here are the 5 most common problems and how to solve them:

### 1) `docker build` fails with `COPY failed: file not found`

- **Cause:** You are likely running the `docker build` command from the wrong directory.
- **Solution:** Use `cd` to navigate to the **root folder** of your project (where the Dockerfile is located) and run the command again.

---

### 2) Container starts, but `localhost:8000` shows **"Connection Refused"**

- **Cause:** The application inside the container might have crashed on startup.
- **Solution:** Check the container's logs. Find the container ID with `docker ps`, then view the logs with `docker logs <container_id>`. The output will usually show the Python error.

---

### 3) Frontend loads, but API calls fail (**Error 404 Not Found**)

- **Cause:** Mismatch between API routes in FastAPI and the URLs used in your React code, or incorrect route ordering in `main.py`.
- **Solution:** Open your browser's Developer Tools (F12), go to the **Network** tab, and find the failed request. Check the URL it tried to access and verify it matches a defined route in `app/main.py`. Ensure API routes are defined **before** the static file **catch‑all** route.

---

### 4) Database Error on startup, like **`no such table: users`**

- **Cause:** The application inside the container cannot find the `onboarding.db` file. This is a pathing issue.
- **Solution:** Double-check your Dockerfile for the `COPY artifacts/ ./artifacts/` line. Then, verify the database URL in `app/main.py` is `SQLALCHEMY_DATABASE_URL = "sqlite:///./artifacts/onboarding.db"`.

---

### 5) Application crashes with an **API Key error**

- **Cause:** The environment variables from your `.env` file were not passed into the container.
- **Solution:** Ensure you are using the `--env-file .env` flag in your `docker run` command and that the `.env` file exists and contains the correct keys (e.g., `OPENAI_API_KEY=sk-...`).

---

_That’s it—your New Hire Onboarding Tool should now be deployed in a single Docker container with the frontend served by FastAPI and all APIs available at `/api/*` (as defined in your backend)._
